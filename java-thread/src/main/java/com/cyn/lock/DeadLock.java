package com.cyn.lock;

/**
 * @Description: 避免死锁：破坏其中一个，就可以成功避免死锁的发生
 * <p>
 * 1. 互斥，共享资源 X 和 Y 只能被一个线程占用；
 * 2. 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
 * 3. 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；
 * 4. 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等
 * 待。
 * <p>
 * 锁为的就是互斥。不过其他三个条件都是有
 * 办法破坏掉的，到底如何做呢？
 * 1. 对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。
 * 2. 对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可
 * 以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。
 * 3. 对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性
 * 顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不
 * 存在循环了。
 * @Author: ynchen9
 * @CreateTime: 2022-02-14
 */
public class DeadLock {
}
